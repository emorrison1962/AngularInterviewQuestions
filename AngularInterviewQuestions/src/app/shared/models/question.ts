

// Generated by Typewriter.
// More info: http://frhagn.github.io/Typewriter/

// $Classes/Enums/Interfaces(filter)[template][separator]
// filter (optional): Matches the name or full name of the current item. * = match 
// any, wrap in [] to match attributes or prefix with : to match interfaces or base classes.
// template: The template to repeat for each matched item
// separator (optional): A separator template that is placed between all templates 
// e.g. $Properties[public $name: $Type][, ]

/* tslint:disable:no-inferrable-types*/




export interface IQuestion {

    QuestionId: number
    Text: string
    Category: string
    Code: string[]
}

export class Question implements IQuestion {

    QuestionId: number = 0;
    Text: string = null;
    Category: string = null;
    Code: string[] = [];

    constructor(src?: IQuestion) {
        if (src) {
            this.QuestionId = src.QuestionId;
            this.Text = src.Text;
            this.Category = src.Category;
            this.Code = src.Code;
        }
    }

    static fromJson(data: any): Question {
        let result = new Question();
        Object.assign(result, data);
        return result;
    }

}

export interface IAnswer {

    AnsweerId: number
    QuestionId: number
    Text: string
    Html: string
    TypeScript: string
}

export class Answer implements IAnswer {

    AnsweerId: number = 0;
    QuestionId: number = 0;
    Text: string = null;
    Html: string = null;
    TypeScript: string = null;

    constructor(src?: IAnswer) {
        if (src) {
            this.AnsweerId = src.AnsweerId;
            this.QuestionId = src.QuestionId;
            this.Text = src.Text;
            this.Html = src.Html;
            this.TypeScript = src.TypeScript;
        }
    }

    static fromJson(data: any): Answer {
        let result = new Answer();
        Object.assign(result, data);
        return result;
    }

}





