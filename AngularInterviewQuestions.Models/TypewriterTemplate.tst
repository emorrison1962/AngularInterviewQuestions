${
	// Enable extension methods by adding using Typewriter.Extensions.*
	using Typewriter.Extensions.Types;

	// Uncomment the constructor to change template settings.
	Template(Settings settings)
	{
	//    settings.IncludeProject("Project.Name");
	//    settings.OutputExtension = ".tsx";

	}
		string Imports(Class c) => c.Properties
			.Where(p=>!p.Type.IsPrimitive || p.Type.IsEnum)
			.Select(p=> $"import {{ {p.Type.Name} }} from './{p.Type.Name}';")
			.Aggregate("", (all,import) => $"{all}{import}\r\n")
			.TrimStart();

	// Custom extension methods can be used in the template by adding a $ prefix e.g. $LoudName
	string LoudName(Property property)
	{
		return property.Name.ToUpperInvariant();
	}
}

// Generated by Typewriter.
// More info: http://frhagn.github.io/Typewriter/

// $Classes/Enums/Interfaces(filter)[template][separator]
// filter (optional): Matches the name or full name of the current item. * = match 
// any, wrap in [] to match attributes or prefix with : to match interfaces or base classes.
// template: The template to repeat for each matched item
// separator (optional): A separator template that is placed between all templates 
// e.g. $Properties[public $name: $Type][, ]

/* tslint:disable:no-inferrable-types*/


$Classes(*)[$Imports

export interface I$Name {
	$Properties[
	$Name: $Type]
}

export class $Name implements I$Name {
	$Properties[
	$Name: $Type = $Type[$Default];]

	constructor(src?: I$Name) {
		if (src) {$Properties[
			this.$Name = src.$Name;]
		}
	}

    static fromJson(data: any): $Name {
        let result = new $Name();
        Object.assign(result, data);
        return result;
    }

}]

$Enums(*)[
export enum $Name { $Values[
	$Name = $Value][,]
}
]



